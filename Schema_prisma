// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// Enums para tipos fixos
enum DeckType {
  NORMAL     // Rider-Waite
  EGIPCIO    // Thoth-inspired
}

enum SpreadType {
  SINGLE     // 1 carta
  THREE_CARD // Passado/Presente/Futuro
  CELTIC_CROSS // 10 cartas
  // Adicione mais spreads no futuro
}

enum SubscriptionPlan {
  FREE
  PREMIUM_MONTHLY
  // Adicione anual ou outros
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

// Modelo principal: Usuário
model User {
  id             String    @id @default(auto()) @map("_id") @db.ObjectId
  email          String    @unique
  passwordHash   String?   // Hash via bcrypt no backend; null para social login
  name           String?   // Opcional
  birthDate      DateTime? // Para mapa astral
  birthTime      String?   // Ex.: "14:30"
  birthLocation  String?   // Ex.: "São Paulo, BR" (latitude/longitude derivado via API)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?   @db.ObjectId
  readings       TarotReading[] // Histórico de tiragens
  birthChart     BirthChart?    // Mapa astral (1:1 para simplicidade)
}

// Modelo: Tiragem de Tarot
model TarotReading {
  id                     String    @id @default(auto()) @map("_id") @db.ObjectId
  userId                 String    @db.ObjectId
  deckType               DeckType
  spreadType             SpreadType
  cards                  Json      // Array de objetos: [{cardName: "The Fool", position: 1, upright: true}]
  interpretation         String?   // Texto gerado via IA; null para teaser
  astrologicalIntegration Json?     // Objeto: {planet: "Venus", aspect: "Challenge"}; integrado via AstroSeek
  isPremium              Boolean   @default(false) // True após pagamento
  createdAt              DateTime  @default(now())
  user                   User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId]) // Para buscas rápidas no histórico
  @@index([createdAt(sort: Desc)]) // Ordenação por data recente
}

// Modelo: Mapa Astral (gerado via AstroSeek API)
model BirthChart {
  id         String    @id @default(auto()) @map("_id") @db.ObjectId
  userId     String    @db.ObjectId @unique // 1:1 com User
  chartData  Json      // Dados da API: {planets: {sun: {sign: "Scorpio", degree: 15}}, houses: [...], aspects: [...]}
  transits   Json?     // Previsões diárias: {date: "2025-11-13", events: [...]}
  generatedAt DateTime @default(now())
  updatedAt  DateTime  @updatedAt
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Modelo: Assinatura (para premium recorrente)
model Subscription {
  id        String          @id @default(auto()) @map("_id") @db.ObjectId
  userId    String          @db.ObjectId @unique // 1:1 por usuário (atualize se múltiplas)
  plan      SubscriptionPlan
  status    String          // Ex.: "active", "canceled" (atualizado via Stripe webhook)
  startDate DateTime
  endDate   DateTime?
  stripeId  String?         // ID da assinatura no Stripe
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Modelo: Pagamento (para one-time ou tracking)
model Payment {
  id          String        @id @default(auto()) @map("_id") @db.ObjectId
  userId      String        @db.ObjectId
  amount      Float         // Ex.: 9.90
  currency    String        @default("BRL")
  status      PaymentStatus
  stripeId    String?       // Session ou PaymentIntent ID
  readingId   String?       @db.ObjectId // Link para tiragem one-time
  createdAt   DateTime      @default(now())
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  reading     TarotReading? @relation(fields: [readingId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([status])
}